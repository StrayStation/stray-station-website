<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Fractology - Transform birthdays, anniversaries, and meaningful dates into stunning fractal artwork. Each date creates a unique mathematical signature.">
    <title>Fractology - Turn Dates into Art</title>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@300;400;600&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-deep: #0a0e27;
            --bg-mid: #1a1f3a;
            --bg-light: #2a2f4a;
            --accent-gold: #d4af37;
            --accent-amber: #ff9500;
            --text-primary: #e8e6e3;
            --text-secondary: #a8a6a3;
        }

        body {
            font-family: 'Crimson Pro', serif;
            background: linear-gradient(135deg, var(--bg-deep) 0%, #1a1232 50%, #0f1a3a 100%);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle at 20% 30%, rgba(212, 175, 55, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(255, 149, 0, 0.02) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 60px 40px;
            position: relative;
            z-index: 1;
        }

        header {
            text-align: center;
            margin-bottom: 60px;
            animation: fadeInDown 1s ease-out;
        }

        h1 {
            font-size: clamp(2.5rem, 5vw, 4rem);
            font-weight: 300;
            letter-spacing: 0.02em;
            margin-bottom: 16px;
            background: linear-gradient(135deg, var(--accent-gold) 0%, var(--accent-amber) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .tagline {
            font-size: 1.2rem;
            color: var(--text-secondary);
            font-weight: 300;
            letter-spacing: 0.05em;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1.5fr;
            gap: 40px;
            margin-bottom: 40px;
            animation: fadeIn 1.2s ease-out 0.3s both;
        }

        .control-panel {
            background: rgba(26, 31, 58, 0.6);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(212, 175, 55, 0.1);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
        }

        .input-group {
            margin-bottom: 24px;
        }

        label {
            display: block;
            font-family: 'Space Mono', monospace;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--accent-gold);
            margin-bottom: 12px;
        }

        input[type="date"],
        input[type="text"],
        select {
            width: 100%;
            padding: 16px 20px;
            background: rgba(42, 47, 74, 0.5);
            border: 2px solid rgba(212, 175, 55, 0.2);
            border-radius: 12px;
            color: var(--text-primary);
            font-family: 'Crimson Pro', serif;
            font-size: 1.1rem;
            transition: all 0.3s ease;
        }

        select {
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg width='12' height='8' viewBox='0 0 12 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L6 6L11 1' stroke='%23d4af37' stroke-width='2' stroke-linecap='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 20px center;
            padding-right: 50px;
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--accent-gold);
            background: rgba(42, 47, 74, 0.8);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.2);
        }

        input[type="date"]::-webkit-calendar-picker-indicator {
            filter: invert(0.7) sepia(1) saturate(5) hue-rotate(5deg);
            cursor: pointer;
        }

        .theme-toggle {
            margin-bottom: 24px;
        }

        .theme-toggle-btn {
            width: 100%;
            padding: 14px 20px;
            background: rgba(42, 47, 74, 0.3);
            border: 2px dashed rgba(212, 175, 55, 0.3);
            border-radius: 12px;
            color: var(--text-secondary);
            font-family: 'Crimson Pro', serif;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .theme-toggle-btn:hover {
            background: rgba(42, 47, 74, 0.5);
            border-color: rgba(212, 175, 55, 0.5);
            color: var(--text-primary);
        }

        .theme-toggle-btn::after {
            content: '▼';
            font-size: 0.8rem;
            transition: transform 0.3s ease;
        }

        .theme-toggle-btn.active::after {
            transform: rotate(180deg);
        }

        .theme-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .theme-content.active {
            max-height: 300px;
            margin-top: 12px;
        }

        .dates-container {
            margin-bottom: 16px;
        }

        .date-entry {
            display: grid;
            grid-template-columns: 1fr 1.2fr auto;
            gap: 8px;
            margin-bottom: 12px;
            align-items: center;
        }

        .date-entry input {
            padding: 12px 16px;
            font-size: 1rem;
        }

        .date-label-input {
            font-family: 'Space Mono', monospace;
            font-size: 0.9rem !important;
        }

        .remove-date {
            width: 40px;
            height: 40px;
            background: rgba(255, 59, 48, 0.2);
            border: 2px solid rgba(255, 59, 48, 0.4);
            border-radius: 8px;
            color: #ff3b30;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        .remove-date:hover {
            background: rgba(255, 59, 48, 0.3);
            border-color: #ff3b30;
        }

        .button-group {
            display: flex;
            gap: 12px;
            margin-top: 24px;
        }

        button {
            flex: 1;
            padding: 16px 28px;
            background: linear-gradient(135deg, var(--accent-gold) 0%, var(--accent-amber) 100%);
            border: none;
            border-radius: 12px;
            color: var(--bg-deep);
            font-family: 'Space Mono', monospace;
            font-size: 0.9rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 24px rgba(212, 175, 55, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 32px rgba(212, 175, 55, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: rgba(212, 175, 55, 0.1);
            color: var(--accent-gold);
            border: 2px solid var(--accent-gold);
            box-shadow: none;
        }

        button.secondary:hover {
            background: rgba(212, 175, 55, 0.2);
        }

        .canvas-container {
            background: rgba(10, 14, 39, 0.8);
            border: 1px solid rgba(212, 175, 55, 0.15);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: auto;
            display: block;
            border-radius: 12px;
            position: relative;
            z-index: 1;
        }

        .date-info {
            margin-top: 20px;
            padding: 20px;
            background: rgba(26, 31, 58, 0.4);
            border-radius: 12px;
            border-left: 4px solid var(--accent-gold);
        }

        .date-info h3 {
            font-family: 'Space Mono', monospace;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--accent-gold);
            margin-bottom: 12px;
        }

        .date-info p {
            font-size: 1rem;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        .examples {
            text-align: center;
            animation: fadeIn 1.4s ease-out 0.6s both;
        }

        .examples h2 {
            font-size: 1.8rem;
            font-weight: 300;
            color: var(--accent-gold);
            margin-bottom: 24px;
        }

        .example-dates {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .example-date {
            padding: 12px 24px;
            background: rgba(26, 31, 58, 0.4);
            border: 1px solid rgba(212, 175, 55, 0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Space Mono', monospace;
            font-size: 0.85rem;
        }

        .example-date:hover {
            background: rgba(212, 175, 55, 0.1);
            border-color: var(--accent-gold);
            transform: translateY(-2px);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--accent-gold);
            font-family: 'Space Mono', monospace;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            z-index: 10;
            text-align: center;
        }

        .loading-subtext {
            font-size: 0.75rem;
            margin-top: 8px;
            opacity: 0.7;
        }

        .hidden {
            display: none;
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @media (max-width: 968px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            .container {
                padding: 40px 20px;
            }
            .date-entry {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Fractology</h1>
            <p class="tagline">The art of meaningful mathematics</p>
        </header>

        <div class="main-grid">
            <div class="control-panel">
                <div class="input-group">
                    <label for="fractalType">Fractal Type</label>
                    <select id="fractalType">
                        <option value="mandelbrot">Mandelbrot Set</option>
                        <option value="newton">Newton Fractal</option>
                        <option value="phoenix">Phoenix Fractal</option>
                        <option value="lsystem">L-System (Nature)</option>
                    </select>
                </div>

                <div class="theme-toggle" id="mandelbrotTheme">
                    <button class="theme-toggle-btn" id="mandelbrotThemeBtn">
                        Looking for a particular theme?
                    </button>
                    <div class="theme-content" id="mandelbrotThemeContent">
                        <select id="mandelbrotRegion">
                            <option value="auto">Auto (Date-Driven)</option>
                            <option value="seahorse">Seahorse Valley</option>
                            <option value="elephant">Elephant Valley</option>
                            <option value="spiral">Double Spiral</option>
                            <option value="minibrot">Mini Universe</option>
                            <option value="scepter">Scepter Valley</option>
                            <option value="triple">Triple Spiral</option>
                            <option value="galaxy">Star Galaxy</option>
                            <option value="jewel">Jewel Box</option>
                            <option value="dragon">Dragon Spine</option>
                            <option value="snowflake">Cosmic Snowflake</option>
                            <option value="cathedral">Crystal Cathedral</option>
                            <option value="nebula">Nebula Clouds</option>
                        </select>
                    </div>
                </div>

                <div class="theme-toggle hidden" id="lsystemTheme">
                    <button class="theme-toggle-btn" id="lsystemThemeBtn">
                        Looking for a particular pattern?
                    </button>
                    <div class="theme-content" id="lsystemThemeContent">
                        <select id="lsystemPattern">
                            <option value="auto">Auto (Date-Driven)</option>
                            <option value="fern">Classic Fern</option>
                            <option value="tree">Branching Tree</option>
                            <option value="spiral">Spiral Vine</option>
                            <option value="crystal">Crystal Bush</option>
                            <option value="dragon">Dragon Curve</option>
                            <option value="coral">Coral Formation</option>
                            <option value="lightning">Lightning Branch</option>
                            <option value="galaxy">Spiral Galaxy</option>
                        </select>
                    </div>
                </div>

                <label style="margin-top: 24px;">Your Dates</label>
                <div class="dates-container" id="datesContainer">
                    <div class="date-entry">
                        <input type="text" class="date-label-input" placeholder="Label" value="First Date">
                        <input type="date" class="date-input" value="1990-01-15">
                        <button class="remove-date hidden">×</button>
                    </div>
                </div>

                <button id="addDateBtn" class="secondary" style="width: 100%; margin-bottom: 20px;">+ Add Another Date</button>

                <div class="button-group">
                    <button id="generateBtn">Generate Art</button>
                    <button id="downloadBtn" class="secondary">Download</button>
                </div>

                <div class="date-info" id="dateInfo">
                    <h3>Artistic Fractal Generator</h3>
                    <p>Add one or more meaningful dates. Multiple dates layer together to create unique compositions with depth and dimension.</p>
                </div>
            </div>

            <div class="canvas-container">
                <div class="loading hidden" id="loading">
                    <div>Generating...</div>
                    <div class="loading-subtext" id="loadingSubtext"></div>
                </div>
                <canvas id="fractalCanvas" width="1200" height="1200"></canvas>
            </div>
        </div>

        <div class="examples">
            <h2>Try These Examples</h2>
            <div class="example-dates">
                <div class="example-date" data-dates='[{"label":"Moon Landing","date":"1969-07-20"}]'>Moon Landing</div>
                <div class="example-date" data-dates='[{"label":"Y2K","date":"2000-01-01"}]'>Y2K</div>
                <div class="example-date" data-dates='[{"label":"Mom","date":"1965-03-15"},{"label":"Dad","date":"1963-11-22"}]'>Parents' Birthdays</div>
                <div class="example-date" data-dates='[{"label":"Emma","date":"2010-06-12"},{"label":"Liam","date":"2012-09-08"},{"label":"Ava","date":"2015-02-14"}]'>Three Kids</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('fractalCanvas');
        const ctx = canvas.getContext('2d');
        const fractalTypeSelect = document.getElementById('fractalType');
        const mandelbrotRegionSelect = document.getElementById('mandelbrotRegion');
        const lsystemPatternSelect = document.getElementById('lsystemPattern');
        const datesContainer = document.getElementById('datesContainer');
        const addDateBtn = document.getElementById('addDateBtn');
        const generateBtn = document.getElementById('generateBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const dateInfo = document.getElementById('dateInfo');
        const loading = document.getElementById('loading');
        const loadingSubtext = document.getElementById('loadingSubtext');
        const exampleDates = document.querySelectorAll('.example-date');

        // Theme toggles
        const mandelbrotTheme = document.getElementById('mandelbrotTheme');
        const lsystemTheme = document.getElementById('lsystemTheme');
        const mandelbrotThemeBtn = document.getElementById('mandelbrotThemeBtn');
        const lsystemThemeBtn = document.getElementById('lsystemThemeBtn');
        const mandelbrotThemeContent = document.getElementById('mandelbrotThemeContent');
        const lsystemThemeContent = document.getElementById('lsystemThemeContent');

        // High resolution canvas
        const scale = 1.5;
        canvas.width = 1200 * scale;
        canvas.height = 1200 * scale;
        ctx.scale(scale, scale);

        // 12 Curated Beautiful Mandelbrot Regions (with corrected zoom levels)
        const mandelbrotRegions = {
            seahorse: { x: -0.7435669, y: 0.1314023, zoom: 0.00003, name: "Seahorse Valley" },
            elephant: { x: 0.28693186, y: 0.01, zoom: 0.00005, name: "Elephant Valley" },
            spiral: { x: -0.16, y: 1.0405, zoom: 0.00015, name: "Double Spiral" },
            minibrot: { x: -0.7453, y: 0.1127, zoom: 0.000008, name: "Mini Universe" },
            scepter: { x: -1.25066, y: 0.02012, zoom: 0.0001, name: "Scepter Valley" },
            triple: { x: -0.7269, y: 0.1889, zoom: 0.00003, name: "Triple Spiral" },
            galaxy: { x: 0.4244, y: 0.2003, zoom: 0.00008, name: "Star Galaxy" },
            jewel: { x: -0.7, y: 0.3, zoom: 0.00006, name: "Jewel Box" },
            dragon: { x: -0.1592, y: -1.0317, zoom: 0.00005, name: "Dragon Spine" },
            snowflake: { x: -0.7443, y: 0.1318, zoom: 0.00002, name: "Cosmic Snowflake" },
            cathedral: { x: -0.748, y: 0.1, zoom: 0.00002, name: "Crystal Cathedral" },
            nebula: { x: -0.75, y: 0.15, zoom: 0.00004, name: "Nebula Clouds" }
        };

        // L-System Rules (with auto-scaling parameters)
        const lsystemRules = {
            fern: { axiom: 'X', rules: { X: 'F+[[X]-X]-F[-FX]+X', F: 'FF' }, angle: 25, length: 4, iterations: 6, startY: 950, name: "Classic Fern" },
            tree: { axiom: 'X', rules: { X: 'F[+X][-X]FX', F: 'FF' }, angle: 25, length: 5, iterations: 6, startY: 950, name: "Branching Tree" },
            spiral: { axiom: 'F', rules: { F: 'F[+F][-F]F[+F][-F]' }, angle: 30, length: 4, iterations: 5, startY: 900, name: "Spiral Vine" },
            crystal: { axiom: 'F', rules: { F: 'FF-[-F+F+F]+[+F-F-F]' }, angle: 22.5, length: 4, iterations: 5, startY: 900, name: "Crystal Bush" },
            dragon: { axiom: 'FX', rules: { X: 'X+YF+', Y: '-FX-Y' }, angle: 90, length: 2, iterations: 14, startY: 600, name: "Dragon Curve" },
            coral: { axiom: 'F', rules: { F: 'F[+F]F[-F][F]' }, angle: 20, length: 4, iterations: 5, startY: 950, name: "Coral Formation" },
            lightning: { axiom: 'F', rules: { F: 'F[+F][-F]' }, angle: 35, length: 5, iterations: 6, startY: 950, name: "Lightning Branch" },
            galaxy: { axiom: 'X', rules: { X: '-YF+XFX+FY-', Y: '+XF-YFY-FX+' }, angle: 60, length: 3, iterations: 6, startY: 600, name: "Spiral Galaxy" }
        };

        // Color Palettes - Dark to bright (backgrounds to highlights)
        const palettes = {
            cosmic: [
                { pos: 0.0, color: [10, 15, 45] },
                { pos: 0.2, color: [25, 50, 120] },
                { pos: 0.4, color: [100, 140, 200] },
                { pos: 0.6, color: [212, 175, 55] },
                { pos: 0.8, color: [255, 200, 100] },
                { pos: 1.0, color: [255, 255, 255] }
            ],
            fire: [
                { pos: 0.0, color: [0, 0, 20] },
                { pos: 0.2, color: [50, 0, 80] },
                { pos: 0.4, color: [120, 20, 100] },
                { pos: 0.6, color: [200, 50, 50] },
                { pos: 0.8, color: [255, 150, 30] },
                { pos: 1.0, color: [255, 255, 200] }
            ],
            ocean: [
                { pos: 0.0, color: [0, 5, 15] },
                { pos: 0.2, color: [0, 30, 60] },
                { pos: 0.4, color: [0, 70, 120] },
                { pos: 0.6, color: [30, 140, 180] },
                { pos: 0.8, color: [100, 200, 220] },
                { pos: 1.0, color: [200, 240, 255] }
            ],
            sunset: [
                { pos: 0.0, color: [20, 10, 40] },
                { pos: 0.2, color: [80, 30, 80] },
                { pos: 0.4, color: [150, 50, 100] },
                { pos: 0.6, color: [220, 100, 80] },
                { pos: 0.8, color: [255, 180, 100] },
                { pos: 1.0, color: [255, 240, 200] }
            ],
            rainbow: [
                { pos: 0.0, color: [20, 0, 40] },
                { pos: 0.2, color: [75, 0, 130] },
                { pos: 0.35, color: [0, 0, 255] },
                { pos: 0.5, color: [0, 180, 0] },
                { pos: 0.65, color: [255, 255, 0] },
                { pos: 0.8, color: [255, 127, 0] },
                { pos: 1.0, color: [255, 50, 50] }
            ],
            emerald: [
                { pos: 0.0, color: [0, 20, 10] },
                { pos: 0.3, color: [0, 60, 40] },
                { pos: 0.5, color: [20, 120, 80] },
                { pos: 0.7, color: [50, 200, 150] },
                { pos: 0.85, color: [100, 255, 200] },
                { pos: 1.0, color: [200, 255, 240] }
            ],
            purple: [
                { pos: 0.0, color: [10, 0, 20] },
                { pos: 0.2, color: [40, 0, 80] },
                { pos: 0.4, color: [100, 20, 150] },
                { pos: 0.6, color: [180, 80, 220] },
                { pos: 0.8, color: [255, 150, 255] },
                { pos: 1.0, color: [255, 220, 255] }
            ],
            amber: [
                { pos: 0.0, color: [20, 10, 0] },
                { pos: 0.3, color: [80, 40, 0] },
                { pos: 0.5, color: [160, 100, 20] },
                { pos: 0.7, color: [220, 160, 40] },
                { pos: 0.85, color: [255, 220, 100] },
                { pos: 1.0, color: [255, 250, 200] }
            ]
        };

        // Theme toggle handlers
        mandelbrotThemeBtn.addEventListener('click', () => {
            mandelbrotThemeBtn.classList.toggle('active');
            mandelbrotThemeContent.classList.toggle('active');
        });

        lsystemThemeBtn.addEventListener('click', () => {
            lsystemThemeBtn.classList.toggle('active');
            lsystemThemeContent.classList.toggle('active');
        });

        // Show/hide theme sections based on fractal type
        fractalTypeSelect.addEventListener('change', () => {
            const type = fractalTypeSelect.value;
            mandelbrotTheme.classList.toggle('hidden', type !== 'mandelbrot');
            lsystemTheme.classList.toggle('hidden', type !== 'lsystem');
        });

        function hashString(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) - hash) + str.charCodeAt(i);
                hash = hash & hash;
            }
            return Math.abs(hash);
        }

        function interpolateColor(palette, t) {
            t = Math.max(0, Math.min(1, t));
            for (let i = 0; i < palette.length - 1; i++) {
                if (t >= palette[i].pos && t <= palette[i + 1].pos) {
                    const localT = (t - palette[i].pos) / (palette[i + 1].pos - palette[i].pos);
                    const c1 = palette[i].color;
                    const c2 = palette[i + 1].color;
                    return [
                        Math.round(c1[0] + (c2[0] - c1[0]) * localT),
                        Math.round(c1[1] + (c2[1] - c1[1]) * localT),
                        Math.round(c1[2] + (c2[2] - c1[2]) * localT)
                    ];
                }
            }
            return palette[palette.length - 1].color;
        }

        function getDateParams(date, label) {
            const d = new Date(date);
            const year = d.getFullYear();
            const month = d.getMonth() + 1;
            const day = d.getDate();
            const hash = hashString(date);
            const digitSum = String(year).split('').reduce((a, b) => a + parseInt(b), 0) + month + day;
            
            // Region selection
            const regionKeys = Object.keys(mandelbrotRegions);
            const regionIndex = hash % regionKeys.length;
            const regionKey = regionKeys[regionIndex];
            const region = mandelbrotRegions[regionKey];
            
            // Fine position offset within region
            const positionOffset = (day + month * 31) / 400 * 0.00002;
            
            // Zoom depth variation
            const zoomMod = 1 + (digitSum % 10) / 10;
            
            // Rotation
            const rotation = (day * 11.6) % 360;
            
            // Color phase
            const colorPhase = (month * day) / 372;
            
            // Iterations
            const iterations = 500 + digitSum * 50;
            
            return {
                year, month, day, hash, label, digitSum,
                region: region,
                regionKey: regionKey,
                centerX: region.x + positionOffset * Math.cos(rotation * Math.PI / 180),
                centerY: region.y + positionOffset * Math.sin(rotation * Math.PI / 180),
                zoom: region.zoom * zoomMod,
                rotation: rotation,
                colorPhase: colorPhase,
                iterations: Math.min(2000, iterations)
            };
        }

        function smoothMandelbrot(x, y, maxIter) {
            let zx = 0, zy = 0;
            let iteration = 0;
            
            while (zx * zx + zy * zy < 256 && iteration < maxIter) {
                const xtemp = zx * zx - zy * zy + x;
                zy = 2 * zx * zy + y;
                zx = xtemp;
                iteration++;
            }
            
            if (iteration < maxIter) {
                const log_zn = Math.log(zx * zx + zy * zy) / 2;
                const nu = Math.log(log_zn / Math.log(2)) / Math.log(2);
                iteration = iteration + 1 - nu;
            }
            
            return iteration;
        }

        function newton(x, y, maxIter) {
            let zx = x, zy = y;
            let iteration = 0;
            
            while (iteration < maxIter) {
                const zx2 = zx * zx;
                const zy2 = zy * zy;
                const zx3 = zx * (zx2 - 3 * zy2);
                const zy3 = zy * (3 * zx2 - zy2);
                
                const fzx = zx3 - 1;
                const fzy = zy3;
                
                const dfzx = 3 * (zx2 - zy2);
                const dfzy = 6 * zx * zy;
                
                const denom = dfzx * dfzx + dfzy * dfzy;
                if (denom < 0.000001) break;
                
                const quotient_real = (fzx * dfzx + fzy * dfzy) / denom;
                const quotient_imag = (fzy * dfzx - fzx * dfzy) / denom;
                
                zx = zx - quotient_real;
                zy = zy - quotient_imag;
                
                iteration++;
                
                if (quotient_real * quotient_real + quotient_imag * quotient_imag < 0.000001) {
                    break;
                }
            }
            
            return iteration;
        }

        function phoenix(x, y, maxIter, c, p) {
            let zx = x, zy = y;
            let px = 0, py = 0;
            let iteration = 0;
            
            while (zx * zx + zy * zy < 16 && iteration < maxIter) {
                const newzx = zx * zx - zy * zy + c + p * px;
                const newzy = 2 * zx * zy;
                px = zx;
                py = zy;
                zx = newzx;
                zy = newzy;
                iteration++;
            }
            
            if (iteration < maxIter) {
                const log_zn = Math.log(zx * zx + zy * zy) / 2;
                const nu = Math.log(log_zn / Math.log(2)) / Math.log(2);
                iteration = iteration + 1 - nu;
            }
            
            return iteration;
        }

        function generateLSystem(rule, iterations) {
            let current = rule.axiom;
            for (let i = 0; i < iterations; i++) {
                let next = '';
                for (let char of current) {
                    next += rule.rules[char] || char;
                }
                current = next;
            }
            return current;
        }

        function drawLSystem(instructions, params, palette, colorPhase) {
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, 1200, 1200);
            
            ctx.save();
            ctx.translate(600, params.startY || 900);
            ctx.rotate(-Math.PI / 2);
            
            const stack = [];
            const angleRad = (params.angle + params.day / 4) * Math.PI / 180;
            const segmentLength = params.length;
            
            for (let i = 0; i < instructions.length; i++) {
                const char = instructions[i];
                const progress = i / instructions.length;
                
                switch(char) {
                    case 'F':
                        const t = (progress + colorPhase) % 1.0;
                        const color = interpolateColor(palette, t);
                        ctx.strokeStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                        ctx.lineWidth = Math.max(0.5, 4 - progress * 3);
                        
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(0, segmentLength);
                        ctx.stroke();
                        ctx.translate(0, segmentLength);
                        break;
                    case '+':
                        ctx.rotate(angleRad);
                        break;
                    case '-':
                        ctx.rotate(-angleRad);
                        break;
                    case '[':
                        stack.push([ctx.getTransform().e, ctx.getTransform().f, 
                                   Math.atan2(ctx.getTransform().b, ctx.getTransform().a)]);
                        ctx.save();
                        break;
                    case ']':
                        ctx.restore();
                        if (stack.length > 0) stack.pop();
                        break;
                }
            }
            
            ctx.restore();
        }

        function renderFractalLayer(params, fractalType, palette, width, height) {
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;
            const maxIter = params.iterations;
            
            if (fractalType === 'lsystem') {
                // L-system rendering is different
                return null;
            }
            
            for (let py = 0; py < height; py++) {
                for (let px = 0; px < width; px++) {
                    let iterations = 0;
                    
                    if (fractalType === 'mandelbrot') {
                        const x0 = params.centerX + (px / width - 0.5) * params.zoom * 4;
                        const y0 = params.centerY + (py / height - 0.5) * params.zoom * 4;
                        iterations = smoothMandelbrot(x0, y0, maxIter);
                    } else if (fractalType === 'newton') {
                        const x0 = (px / width - 0.5) * 4;
                        const y0 = (py / height - 0.5) * 4;
                        iterations = newton(x0, y0, maxIter);
                    } else if (fractalType === 'phoenix') {
                        const x0 = (px / width - 0.5) * 4;
                        const y0 = (py / height - 0.5) * 4;
                        const c = -0.5 + params.colorPhase * 0.3;
                        const p = 0.5666;
                        iterations = phoenix(x0, y0, maxIter, c, p);
                    }
                    
                    const index = (py * width + px) * 4;
                    
                    if (iterations >= maxIter - 0.5) {
                        data[index] = 0;
                        data[index + 1] = 0;
                        data[index + 2] = 0;
                        data[index + 3] = 255;
                    } else {
                        const t = (iterations / maxIter + params.colorPhase) % 1.0;
                        const color = interpolateColor(palette, t);
                        
                        data[index] = color[0];
                        data[index + 1] = color[1];
                        data[index + 2] = color[2];
                        data[index + 3] = 255;
                    }
                }
            }
            
            return imageData;
        }

        function applyWatermark() {
            // Create a temporary canvas for watermarked version
            const watermarkedCanvas = document.createElement('canvas');
            watermarkedCanvas.width = canvas.width;
            watermarkedCanvas.height = canvas.height;
            const wctx = watermarkedCanvas.getContext('2d');
            
            // Copy the fractal to watermarked canvas
            wctx.drawImage(canvas, 0, 0);
            
            // Add watermark
            wctx.save();
            
            // Semi-transparent overlay in bottom right
            const watermarkSize = 180;
            const padding = 40;
            
            // Subtle dark overlay
            wctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            wctx.fillRect(
                watermarkedCanvas.width - watermarkSize - padding,
                watermarkedCanvas.height - watermarkSize / 2 - padding,
                watermarkSize,
                watermarkSize / 2
            );
            
            // Stray AI text
            wctx.font = 'bold 48px Space Mono, monospace';
            wctx.fillStyle = 'rgba(212, 175, 55, 0.9)';
            wctx.textAlign = 'right';
            wctx.textBaseline = 'middle';
            wctx.fillText(
                'STRAY AI',
                watermarkedCanvas.width - padding - 20,
                watermarkedCanvas.height - padding - 30
            );
            
            // Small tagline
            wctx.font = '20px Crimson Pro, serif';
            wctx.fillStyle = 'rgba(232, 230, 227, 0.7)';
            wctx.fillText(
                'StrayStation.com',
                watermarkedCanvas.width - padding - 20,
                watermarkedCanvas.height - padding - 5
            );
            
            wctx.restore();
            
            return watermarkedCanvas;
        }

        function applyGlow(imageData, width, height) {
            const data = imageData.data;
            const glowData = ctx.createImageData(width, height);
            const glow = glowData.data;
            
            for (let i = 0; i < data.length; i++) {
                glow[i] = data[i];
            }
            
            const glowRadius = 2;
            for (let y = glowRadius; y < height - glowRadius; y++) {
                for (let x = glowRadius; x < width - glowRadius; x++) {
                    const idx = (y * width + x) * 4;
                    const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                    
                    if (brightness > 150) {
                        const glowIntensity = (brightness - 150) / 105;
                        
                        for (let dy = -glowRadius; dy <= glowRadius; dy++) {
                            for (let dx = -glowRadius; dx <= glowRadius; dx++) {
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist <= glowRadius) {
                                    const targetIdx = ((y + dy) * width + (x + dx)) * 4;
                                    const factor = (1 - dist / glowRadius) * glowIntensity * 0.3;
                                    
                                    glow[targetIdx] = Math.min(255, glow[targetIdx] + data[idx] * factor);
                                    glow[targetIdx + 1] = Math.min(255, glow[targetIdx + 1] + data[idx + 1] * factor);
                                    glow[targetIdx + 2] = Math.min(255, glow[targetIdx + 2] + data[idx + 2] * factor);
                                }
                            }
                        }
                    }
                }
            }
            
            return glowData;
        }

        function getHarmoniousPalettes(count) {
            const paletteKeys = Object.keys(palettes);
            const result = [];
            
            if (count === 1) {
                const idx = Math.floor(Math.random() * paletteKeys.length);
                return [palettes[paletteKeys[idx]]];
            }
            
            // For multiple dates, choose complementary palettes
            const baseIdx = Math.floor(Math.random() * paletteKeys.length);
            result.push(palettes[paletteKeys[baseIdx]]);
            
            // Add complementary palettes
            const complementaryIndices = [
                (baseIdx + Math.floor(paletteKeys.length / 2)) % paletteKeys.length,
                (baseIdx + Math.floor(paletteKeys.length / 3)) % paletteKeys.length
            ];
            
            for (let i = 1; i < count && i - 1 < complementaryIndices.length; i++) {
                result.push(palettes[paletteKeys[complementaryIndices[i - 1]]]);
            }
            
            return result;
        }

        function generateFractal() {
            loading.classList.remove('hidden');
            loadingSubtext.textContent = 'Calculating mathematical beauty...';
            
            setTimeout(() => {
                const dates = getAllDates();
                if (dates.length === 0) {
                    loading.classList.add('hidden');
                    return;
                }
                
                const fractalType = fractalTypeSelect.value;
                const width = 1200;
                const height = 1200;
                
                // Get params for all dates
                const allParams = dates.map(d => getDateParams(d.date, d.label));
                
                // Blend parameters for multiple dates
                let finalParams;
                if (allParams.length === 1) {
                    finalParams = allParams[0];
                } else {
                    // Combine all date hashes to select ONE region
                    const combinedHash = hashString(dates.map(d => d.date).join('-'));
                    
                    // Select region based on combined hash
                    const regionKeys = Object.keys(mandelbrotRegions);
                    const regionIndex = combinedHash % regionKeys.length;
                    const regionKey = regionKeys[regionIndex];
                    const region = mandelbrotRegions[regionKey];
                    
                    // Average the fine-tuning parameters
                    const avgDay = allParams.reduce((sum, p) => sum + p.day, 0) / allParams.length;
                    const avgMonth = allParams.reduce((sum, p) => sum + p.month, 0) / allParams.length;
                    const avgDigitSum = allParams.reduce((sum, p) => sum + p.digitSum, 0) / allParams.length;
                    const avgRotation = allParams.reduce((sum, p) => sum + p.rotation, 0) / allParams.length;
                    
                    // Create blended parameters
                    const positionOffset = (avgDay + avgMonth * 31) / 400 * 0.00002;
                    const zoomMod = 1 + (Math.floor(avgDigitSum) % 10) / 10;
                    
                    finalParams = {
                        region: region,
                        regionKey: regionKey,
                        centerX: region.x + positionOffset * Math.cos(avgRotation * Math.PI / 180),
                        centerY: region.y + positionOffset * Math.sin(avgRotation * Math.PI / 180),
                        zoom: region.zoom * zoomMod,
                        rotation: avgRotation,
                        colorPhase: (avgMonth * avgDay) / 372,
                        iterations: Math.min(2000, 500 + Math.floor(avgDigitSum) * 50),
                        day: avgDay,
                        labels: allParams.map(p => p.label).join(', ')
                    };
                }
                
                // Override region if manually selected
                if (fractalType === 'mandelbrot' && mandelbrotRegionSelect.value !== 'auto') {
                    const manualRegion = mandelbrotRegions[mandelbrotRegionSelect.value];
                    finalParams.region = manualRegion;
                    finalParams.centerX = manualRegion.x + (finalParams.day / 31) * 0.00002;
                    finalParams.centerY = manualRegion.y + ((finalParams.colorPhase || 0.5) * 12) * 0.00002;
                    finalParams.zoom = manualRegion.zoom * (1 + (finalParams.iterations % 100) / 100);
                }
                
                // Handle L-System
                if (fractalType === 'lsystem') {
                    loadingSubtext.textContent = 'Growing organic patterns...';
                    
                    let ruleKey;
                    if (lsystemPatternSelect.value !== 'auto') {
                        ruleKey = lsystemPatternSelect.value;
                    } else {
                        const ruleKeys = Object.keys(lsystemRules);
                        const selectHash = allParams.length > 1 ? 
                            hashString(dates.map(d => d.date).join('-')) : 
                            allParams[0].hash;
                        ruleKey = ruleKeys[selectHash % ruleKeys.length];
                    }
                    
                    const baseRule = lsystemRules[ruleKey];
                    const pattern = {
                        ...baseRule,
                        angle: baseRule.angle + (finalParams.day / 4),
                        iterations: Math.min(baseRule.iterations, 4 + Math.floor(finalParams.day / 8)),
                        day: finalParams.day,
                        colorPhase: finalParams.colorPhase
                    };
                    
                    // Select palette
                    const paletteKeys = Object.keys(palettes);
                    const paletteHash = allParams.length > 1 ? 
                        hashString(dates.map(d => d.date).join('-')) : 
                        allParams[0].hash;
                    const palette = palettes[paletteKeys[paletteHash % paletteKeys.length]];
                    
                    ctx.fillStyle = '#0a0e27';
                    ctx.fillRect(0, 0, 1200, 1200);
                    
                    const instructions = generateLSystem(pattern, pattern.iterations);
                    drawLSystem(instructions, pattern, palette, pattern.colorPhase);
                    
                    loading.classList.add('hidden');
                    updateInfo(dates, fractalType, [finalParams]);
                    return;
                }
                
                // Render single blended fractal for mathematical fractals
                loadingSubtext.textContent = allParams.length > 1 ? 
                    `Blending ${allParams.length} dates into one fractal...` : 
                    'Rendering fractal...';
                
                // Select palette based on combined hash
                const paletteKeys = Object.keys(palettes);
                const paletteHash = allParams.length > 1 ? 
                    hashString(dates.map(d => d.date).join('-')) : 
                    allParams[0].hash;
                const palette = palettes[paletteKeys[paletteHash % paletteKeys.length]];
                
                const layer = renderFractalLayer(finalParams, fractalType, palette, width, height);
                if (layer) {
                    const glowed = applyGlow(layer, width, height);
                    ctx.putImageData(glowed, 0, 0);
                }
                
                loading.classList.add('hidden');
                updateInfo(dates, fractalType, [finalParams]);
            }, 50);
        }

        function getAllDates() {
            const entries = datesContainer.querySelectorAll('.date-entry');
            return Array.from(entries).map(entry => ({
                label: entry.querySelector('.date-label-input').value || 'Date',
                date: entry.querySelector('.date-input').value
            })).filter(d => d.date);
        }

        function addDateEntry(label = '', date = '') {
            const entry = document.createElement('div');
            entry.className = 'date-entry';
            entry.innerHTML = `
                <input type="text" class="date-label-input" placeholder="Label" value="${label}">
                <input type="date" class="date-input" value="${date}">
                <button class="remove-date">×</button>
            `;
            
            entry.querySelector('.remove-date').addEventListener('click', function() {
                entry.remove();
                updateRemoveButtons();
            });
            
            datesContainer.appendChild(entry);
            updateRemoveButtons();
        }

        function updateRemoveButtons() {
            const entries = datesContainer.querySelectorAll('.date-entry');
            entries.forEach(entry => {
                const removeBtn = entry.querySelector('.remove-date');
                removeBtn.classList.toggle('hidden', entries.length === 1);
            });
        }

        function updateInfo(dates, fractalType, params) {
            const datesList = dates.map(d => {
                return `<strong>${d.label}</strong>: ${new Date(d.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}`;
            }).join('<br>');
            
            const typeNames = {
                mandelbrot: 'Mandelbrot Set',
                newton: 'Newton Fractal',
                phoenix: 'Phoenix Fractal',
                lsystem: 'L-System (Nature)'
            };
            
            let regionInfo = '';
            if (fractalType === 'mandelbrot' && params[0].region) {
                regionInfo = `<br><em>Region: ${params[0].region.name}</em>`;
            }
            
            const blendText = dates.length > 1 ? 
                `${dates.length} dates blended into a unique mathematical signature` : 
                'Single date with smooth gradients and glow effects';
            
            dateInfo.innerHTML = `
                <h3>${typeNames[fractalType]}</h3>
                <p style="margin-bottom: 12px;">${datesList}${regionInfo}</p>
                <p style="font-size: 0.9rem;">
                    ${blendText}
                </p>
            `;
        }

        // Event listeners
        generateBtn.addEventListener('click', generateFractal);
        fractalTypeSelect.addEventListener('change', generateFractal);
        mandelbrotRegionSelect.addEventListener('change', generateFractal);
        lsystemPatternSelect.addEventListener('change', generateFractal);
        
        addDateBtn.addEventListener('click', () => {
            addDateEntry('', new Date().toISOString().split('T')[0]);
        });
        
        downloadBtn.addEventListener('click', () => {
            const dates = getAllDates();
            const labels = dates.map(d => d.label).join('-');
            const filename = `fractal-${labels.replace(/\s+/g, '-').toLowerCase()}.png`;
            
            // Apply watermark and download
            const watermarkedCanvas = applyWatermark();
            const link = document.createElement('a');
            link.download = filename;
            link.href = watermarkedCanvas.toDataURL('image/png');
            link.click();
        });
        
        exampleDates.forEach(example => {
            example.addEventListener('click', () => {
                const dates = JSON.parse(example.dataset.dates);
                
                datesContainer.innerHTML = '';
                
                dates.forEach(d => {
                    const entry = document.createElement('div');
                    entry.className = 'date-entry';
                    entry.innerHTML = `
                        <input type="text" class="date-label-input" placeholder="Label" value="${d.label}">
                        <input type="date" class="date-input" value="${d.date}">
                        <button class="remove-date">×</button>
                    `;
                    
                    entry.querySelector('.remove-date').addEventListener('click', function() {
                        entry.remove();
                        updateRemoveButtons();
                    });
                    
                    datesContainer.appendChild(entry);
                });
                
                updateRemoveButtons();
                generateFractal();
            });
        });
        
        // Generate initial fractal
        generateFractal();
    </script>
</body>
</html>
